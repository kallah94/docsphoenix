<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="ExDoc v0.21.2">
    <meta name="project" content="Phoenix v1.4.15">
    <title>Phoenix.Socket â€” Phoenix v1.4.15</title>
    <link rel="stylesheet" href="dist/html-de2388dc2f8074b0a4db.css" />
    <script src="dist/sidebar_items-c08200cd71.js"></script>
      <script src="docs_config.js"></script>
    <script async src="dist/html-de2388dc2f8074b0a4db.js"></script>
  </head>
  <body data-type="modules">
    <script>try { if(localStorage.getItem('night-mode') === 'true') document.body.className += ' night-mode'; } catch (e) { }</script>
<div class="main">

<button class="sidebar-button sidebar-toggle">
  <span class="icon-menu" title="Collapse/expand sidebar"></span>
</button>

<section class="sidebar">
  <form class="sidebar-search" action="search.html">
    <button type="submit" class="search-button">
      <span class="icon-search" aria-hidden="true"></span>
    </button>
    <button type="button" tabindex="-1" class="search-close-button">
      <span class="icon-cross" title="Cancel search"></span>
    </button>
    <label class="search-label">
      <input name="q" type="text" id="search-list" class="search-input" placeholder="Search..." aria-label="Search" autocomplete="off" />
    </label>
  </form>

  <div class="autocomplete">
    <div class="autocomplete-results">
    </div>
  </div>

  <div class="sidebar-header">
    <div class="sidebar-projectDetails">
      <a href="http://www.phoenixframework.org" class="sidebar-projectName">
Phoenix      </a>
      <h2 class="sidebar-projectVersion">
        v1.4.15
      </h2>
    </div>
      <a href="http://www.phoenixframework.org">
        <img src="assets/logo.png" alt="Phoenix" class="sidebar-projectImage">
      </a>
  </div>

  <ul class="sidebar-listNav">
    <li><a id="extras-list" href="#full-list">GUIDES</a></li>

      <li><a id="modules-list" href="#full-list">Modules</a></li>

      <li><a id="exceptions-list" href="#full-list">Exceptions</a></li>

      <li><a id="tasks-list" href="#full-list">Mix Tasks</a></li>
  </ul>
  <div class="gradient"></div>
  <ul id="full-list" class="sidebar-fullList"></ul>
</section>

<section class="content">
  <div class="content-outer">
    <div id="content" class="content-inner">

      <h1>
        <small class="app-vsn">Phoenix v1.4.15</small>
Phoenix.Socket <small>behaviour</small>          <a href="https://github.com/phoenixframework/phoenix/blob/v1.4.15/lib/phoenix/socket.ex#L1" title="View Source" class="view-source" rel="help">
            <span class="icon-code" aria-hidden="true"></span>
            <span class="sr-only">View Source</span>
          </a>
      </h1>


        <section id="moduledoc">
<p>A socket implementation that multiplexes messages over channels.</p>
<p><a href="#content"><code class="inline">Phoenix.Socket</code></a> is used as a module for establishing and maintaining
the socket state via the <a href="#content"><code class="inline">Phoenix.Socket</code></a> struct.</p>
<p>Once connected to a socket, incoming and outgoing events are routed to
channels. The incoming client data is routed to channels via transports.
It is the responsibility of the socket to tie transports and channels
together.</p>
<p>By default, Phoenix supports both websockets and longpoll when invoking
<a href="Phoenix.Endpoint.html#socket/3"><code class="inline">Phoenix.Endpoint.socket/3</code></a> in your endpoint:</p>
<pre><code class="nohighlight makeup elixir"><span class="n">socket</span><span class="w"> </span><span class="s">&quot;/socket&quot;</span><span class="p">,</span><span class="w"> </span><span class="nc">MyApp.Socket</span><span class="p">,</span><span class="w"> </span><span class="ss">websocket</span><span class="p">:</span><span class="w"> </span><span class="no">true</span><span class="p">,</span><span class="w"> </span><span class="ss">longpoll</span><span class="p">:</span><span class="w"> </span><span class="no">false</span></code></pre>
<p>The command above means incoming socket connections can be made via
a WebSocket connection. Events are routed by topic to channels:</p>
<pre><code class="nohighlight makeup elixir"><span class="n">channel</span><span class="w"> </span><span class="s">&quot;room:lobby&quot;</span><span class="p">,</span><span class="w"> </span><span class="nc">MyApp.LobbyChannel</span></code></pre>
<p>See <a href="Phoenix.Channel.html"><code class="inline">Phoenix.Channel</code></a> for more information on channels.</p>
<h2 id="module-socket-behaviour" class="section-heading">
  <a href="#module-socket-behaviour" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Socket Behaviour
</h2>

<p>Socket handlers are mounted in Endpoints and must define two callbacks:</p>
<ul>
<li><code class="inline">connect/3</code> - receives the socket params, connection info if any, and
authenticates the connection. Must return a <a href="#content"><code class="inline">Phoenix.Socket</code></a> struct,
often with custom assigns
</li>
<li><code class="inline">id/1</code> - receives the socket returned by <code class="inline">connect/3</code> and returns the
id of this connection as a string. The <code class="inline">id</code> is used to identify socket
connections, often to a particular user, allowing us to force disconnections.
For sockets requiring no authentication, <code class="inline">nil</code> can be returned
</li>
</ul>
<h2 id="module-examples" class="section-heading">
  <a href="#module-examples" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Examples
</h2>

<pre><code class="nohighlight makeup elixir"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">MyApp.UserSocket</span><span class="w"> </span><span class="k" data-group-id="7910737182-1">do</span><span class="w">
  </span><span class="kn">use</span><span class="w"> </span><span class="nc">Phoenix.Socket</span><span class="w">

  </span><span class="n">channel</span><span class="w"> </span><span class="s">&quot;room:*&quot;</span><span class="p">,</span><span class="w"> </span><span class="nc">MyApp.RoomChannel</span><span class="w">

  </span><span class="kd">def</span><span class="w"> </span><span class="nf">connect</span><span class="p" data-group-id="7910737182-2">(</span><span class="n">params</span><span class="p">,</span><span class="w"> </span><span class="n">socket</span><span class="p">,</span><span class="w"> </span><span class="c">_connect_info</span><span class="p" data-group-id="7910737182-2">)</span><span class="w"> </span><span class="k" data-group-id="7910737182-3">do</span><span class="w">
    </span><span class="p" data-group-id="7910737182-4">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="n">assign</span><span class="p" data-group-id="7910737182-5">(</span><span class="n">socket</span><span class="p">,</span><span class="w"> </span><span class="ss">:user_id</span><span class="p">,</span><span class="w"> </span><span class="n">params</span><span class="p" data-group-id="7910737182-6">[</span><span class="s">&quot;user_id&quot;</span><span class="p" data-group-id="7910737182-6">]</span><span class="p" data-group-id="7910737182-5">)</span><span class="p" data-group-id="7910737182-4">}</span><span class="w">
  </span><span class="k" data-group-id="7910737182-3">end</span><span class="w">

  </span><span class="kd">def</span><span class="w"> </span><span class="nf">id</span><span class="p" data-group-id="7910737182-7">(</span><span class="n">socket</span><span class="p" data-group-id="7910737182-7">)</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;users_socket:</span><span class="si" data-group-id="7910737182-8">#{</span><span class="n">socket</span><span class="o">.</span><span class="n">assigns</span><span class="o">.</span><span class="n">user_id</span><span class="si" data-group-id="7910737182-8">}</span><span class="s">&quot;</span><span class="w">
</span><span class="k" data-group-id="7910737182-1">end</span><span class="w">

</span><span class="c1"># Disconnect all user&#39;s socket connections and their multiplexed channels</span><span class="w">
</span><span class="nc">MyApp.Endpoint</span><span class="o">.</span><span class="n">broadcast</span><span class="p" data-group-id="7910737182-9">(</span><span class="s">&quot;users_socket:&quot;</span><span class="w"> </span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="n">user</span><span class="o">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;disconnect&quot;</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="7910737182-10">%{</span><span class="p" data-group-id="7910737182-10">}</span><span class="p" data-group-id="7910737182-9">)</span></code></pre>
<h2 id="module-socket-fields" class="section-heading">
  <a href="#module-socket-fields" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Socket fields
</h2>

<ul>
<li><code class="inline">:id</code> - The string id of the socket
</li>
<li><code class="inline">:assigns</code> - The map of socket assigns, default: <code class="inline">%{}</code>
</li>
<li><code class="inline">:channel</code> - The current channel module
</li>
<li><code class="inline">:channel_pid</code> - The channel pid
</li>
<li><code class="inline">:endpoint</code> - The endpoint module where this socket originated, for example: <code class="inline">MyApp.Endpoint</code>
</li>
<li><code class="inline">:handler</code> - The socket module where this socket originated, for example: <code class="inline">MyApp.UserSocket</code>
</li>
<li><code class="inline">:joined</code> - If the socket has effectively joined the channel
</li>
<li><code class="inline">:join_ref</code> - The ref sent by the client when joining
</li>
<li><code class="inline">:ref</code> - The latest ref sent by the client
</li>
<li><code class="inline">:pubsub_server</code> - The registered name of the socket&#39;s pubsub server
</li>
<li><code class="inline">:topic</code> - The string topic, for example <code class="inline">&quot;room:123&quot;</code>
</li>
<li><code class="inline">:transport</code> - An identifier for the transport, used for logging
</li>
<li><code class="inline">:transport_pid</code> - The pid of the socket&#39;s transport process
</li>
<li><code class="inline">:serializer</code> - The serializer for socket messages
</li>
</ul>
<h2 id="module-logging" class="section-heading">
  <a href="#module-logging" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Logging
</h2>

<p>Logging for socket connections is set via the <code class="inline">:log</code> option, for example:</p>
<pre><code class="nohighlight makeup elixir"><span class="kn">use</span><span class="w"> </span><span class="nc">Phoenix.Socket</span><span class="p">,</span><span class="w"> </span><span class="ss">log</span><span class="p">:</span><span class="w"> </span><span class="ss">:debug</span></code></pre>
<p>Defaults to the <code class="inline">:info</code> log level. Pass <code class="inline">false</code> to disable logging.</p>
<h2 id="module-garbage-collection" class="section-heading">
  <a href="#module-garbage-collection" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Garbage collection
</h2>

<p>It&#39;s possible to force garbage collection in the transport process after
processing large messages. For example, to trigger such from your channels,
run:</p>
<pre><code class="nohighlight makeup elixir"><span class="n">send</span><span class="p" data-group-id="8857391641-1">(</span><span class="n">socket</span><span class="o">.</span><span class="n">transport_pid</span><span class="p">,</span><span class="w"> </span><span class="ss">:garbage_collect</span><span class="p" data-group-id="8857391641-1">)</span></code></pre>
<h2 id="module-client-server-communication" class="section-heading">
  <a href="#module-client-server-communication" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Client-server communication
</h2>

<p>The encoding of server data and the decoding of client data is done
according to a serializer, defined in <a href="Phoenix.Socket.Serializer.html"><code class="inline">Phoenix.Socket.Serializer</code></a>.
By default, JSON encoding is used to broker messages to and from
clients with <code class="inline">Phoenix.Socket.V2.JSONSerializer</code>.</p>
<p>The serializer <code class="inline">decode!</code> function must return a <a href="Phoenix.Socket.Message.html"><code class="inline">Phoenix.Socket.Message</code></a>
which is forwarded to channels except:</p>
<ul>
<li><code class="inline">&quot;heartbeat&quot;</code> events in the &quot;phoenix&quot; topic - should just emit an OK reply
</li>
<li><code class="inline">&quot;phx_join&quot;</code> on any topic - should join the topic
</li>
<li><code class="inline">&quot;phx_leave&quot;</code> on any topic - should leave the topic
</li>
</ul>
<p>Each message also has a <code class="inline">ref</code> field which is used to track responses.</p>
<p>The server may send messages or replies back. For messages, the
ref uniquely identifies the message. For replies, the ref matches
the original message. Both data-types also include a join_ref that
uniquely identifies the currently joined channel.</p>
<p>The <a href="#content"><code class="inline">Phoenix.Socket</code></a> implementation may also send special messages
and replies:</p>
<ul>
<li><p><code class="inline">&quot;phx_error&quot;</code> - in case of errors, such as a channel process
crashing, or when attempting to join an already joined channel</p>
</li>
<li><p><code class="inline">&quot;phx_close&quot;</code> - the channel was gracefully closed</p>
</li>
</ul>
<p>Phoenix ships with a JavaScript implementation of both websocket
and long polling that interacts with Phoenix.Socket and can be
used as reference for those interested in implementing custom clients.</p>
<h2 id="module-custom-sockets-and-transports" class="section-heading">
  <a href="#module-custom-sockets-and-transports" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Custom sockets and transports
</h2>

<p>See the <a href="Phoenix.Socket.Transport.html"><code class="inline">Phoenix.Socket.Transport</code></a> documentation for more information on
writing your own socket that does not leverage channels or for writing
your own transports that interacts with other sockets.</p>
<h2 id="module-custom-channels" class="section-heading">
  <a href="#module-custom-channels" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Custom channels
</h2>

<p>You can list any module as a channel as long as it implements
a <code class="inline">start_link/1</code> function that receives a tuple with three elements:</p>
<pre><code class="nohighlight makeup elixir"><span class="p" data-group-id="9161987413-1">{</span><span class="n">auth_payload</span><span class="p">,</span><span class="w"> </span><span class="n">from</span><span class="p">,</span><span class="w"> </span><span class="n">socket</span><span class="p" data-group-id="9161987413-1">}</span></code></pre>
<p>A custom channel implementation MUST invoke
<code class="inline">GenServer.reply(from, {:ok | :error, reply_payload})</code> during its
initialization with a custom <code class="inline">reply_payload</code> that will be sent as
a reply to the client. Failing to do so will block the socket forever.</p>
<p>A custom channel receives <a href="Phoenix.Socket.Message.html"><code class="inline">Phoenix.Socket.Message</code></a> structs as regular
messages from the transport. Replies to those messages and custom
messages can be sent to the socket at any moment by building an
appropriate <a href="Phoenix.Socket.Reply.html"><code class="inline">Phoenix.Socket.Reply</code></a> and <a href="Phoenix.Socket.Message.html"><code class="inline">Phoenix.Socket.Message</code></a>
structs, encoding them with the serializer and dispatching the
serialized result to the transport.</p>
<p>For example, to handle &quot;phx_leave&quot; messages, which is recommended
to be handled by all channel implementations, one may do:</p>
<pre><code class="nohighlight makeup elixir"><span class="kd">def</span><span class="w"> </span><span class="nf">handle_info</span><span class="p" data-group-id="1467320802-1">(</span><span class="w">
      </span><span class="p" data-group-id="1467320802-2">%</span><span class="nc" data-group-id="1467320802-2">Message</span><span class="p" data-group-id="1467320802-2">{</span><span class="ss">topic</span><span class="p">:</span><span class="w"> </span><span class="n">topic</span><span class="p">,</span><span class="w"> </span><span class="ss">event</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;phx_leave&quot;</span><span class="p" data-group-id="1467320802-2">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">message</span><span class="p">,</span><span class="w">
      </span><span class="p" data-group-id="1467320802-3">%{</span><span class="ss">topic</span><span class="p">:</span><span class="w"> </span><span class="n">topic</span><span class="p">,</span><span class="w"> </span><span class="ss">serializer</span><span class="p">:</span><span class="w"> </span><span class="n">serializer</span><span class="p">,</span><span class="w"> </span><span class="ss">transport_pid</span><span class="p">:</span><span class="w"> </span><span class="n">transport_pid</span><span class="p" data-group-id="1467320802-3">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">socket</span><span class="w">
    </span><span class="p" data-group-id="1467320802-1">)</span><span class="w"> </span><span class="k" data-group-id="1467320802-4">do</span><span class="w">
  </span><span class="n">send</span><span class="w"> </span><span class="n">transport_pid</span><span class="p">,</span><span class="w"> </span><span class="n">serializer</span><span class="o">.</span><span class="n">encode!</span><span class="p" data-group-id="1467320802-5">(</span><span class="n">build_leave_reply</span><span class="p" data-group-id="1467320802-6">(</span><span class="n">message</span><span class="p" data-group-id="1467320802-6">)</span><span class="p" data-group-id="1467320802-5">)</span><span class="w">
  </span><span class="p" data-group-id="1467320802-7">{</span><span class="ss">:stop</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="1467320802-8">{</span><span class="ss">:shutdown</span><span class="p">,</span><span class="w"> </span><span class="ss">:left</span><span class="p" data-group-id="1467320802-8">}</span><span class="p">,</span><span class="w"> </span><span class="n">socket</span><span class="p" data-group-id="1467320802-7">}</span><span class="w">
</span><span class="k" data-group-id="1467320802-4">end</span></code></pre>
<p>We also recommend all channels to monitor the <code class="inline">transport_pid</code>
on <code class="inline">init</code> and exit if the transport exits. We also advise to rewrite
<code class="inline">:normal</code> exit reasons (usually due to the socket being closed)
to the <code class="inline">{:shutdown, :closed}</code> to guarantee links are broken on
the channel exit (as a <code class="inline">:normal</code> exit does not break links):</p>
<pre><code class="nohighlight makeup elixir"><span class="kd">def</span><span class="w"> </span><span class="nf">handle_info</span><span class="p" data-group-id="3837498467-1">(</span><span class="p" data-group-id="3837498467-2">{</span><span class="ss">:DOWN</span><span class="p">,</span><span class="w"> </span><span class="bp">_</span><span class="p">,</span><span class="w"> </span><span class="bp">_</span><span class="p">,</span><span class="w"> </span><span class="n">transport_pid</span><span class="p">,</span><span class="w"> </span><span class="n">reason</span><span class="p" data-group-id="3837498467-2">}</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="3837498467-3">%{</span><span class="ss">transport_pid</span><span class="p">:</span><span class="w"> </span><span class="n">transport_pid</span><span class="p" data-group-id="3837498467-3">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">socket</span><span class="p" data-group-id="3837498467-1">)</span><span class="w"> </span><span class="k" data-group-id="3837498467-4">do</span><span class="w">
  </span><span class="n">reason</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">reason</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="ss">:normal</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="3837498467-5">{</span><span class="ss">:shutdown</span><span class="p">,</span><span class="w"> </span><span class="ss">:closed</span><span class="p" data-group-id="3837498467-5">}</span><span class="p">,</span><span class="w"> </span><span class="ss">else</span><span class="p">:</span><span class="w"> </span><span class="n">reason</span><span class="w">
  </span><span class="p" data-group-id="3837498467-6">{</span><span class="ss">:stop</span><span class="p">,</span><span class="w"> </span><span class="n">reason</span><span class="p">,</span><span class="w"> </span><span class="n">socket</span><span class="p" data-group-id="3837498467-6">}</span><span class="w">
</span><span class="k" data-group-id="3837498467-4">end</span></code></pre>
<p>Any process exit is treated as an error by the socket layer unless
a <code class="inline">{:socket_close, pid, reason}</code> message is sent to the socket before
shutdown.</p>
<p>Custom channel implementations cannot be tested with <a href="Phoenix.ChannelTest.html"><code class="inline">Phoenix.ChannelTest</code></a>
and are currently considered experimental. The underlying API may be
changed at any moment.</p>
<p><strong>Note:</strong> in future Phoenix versions we will require custom channels
to provide a custom <code class="inline">child_spec/1</code> function instead of <code class="inline">start_link/1</code>.
Since the default behaviour of <code class="inline">child_spec/1</code> is to invoke <code class="inline">start_link/1</code>,
this behaviour should be backwards compatible in almost all cases.</p>
        </section>

        <section id="summary" class="details-list">
          <h1 class="section-heading">
            <a class="hover-link" href="#summary">
              <span class="icon-link" aria-hidden="true"></span>
              <span class="sr-only">Link to this section</span>
            </a>
            Summary
          </h1>
  <div class="summary-types summary">
    <h2>
      <a href="#types">Types</a>
    </h2>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#t:t/0">t()</a>
  </div>
</div>
  </div>
  <div class="summary-functions summary">
    <h2>
      <a href="#functions">Functions</a>
    </h2>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#assign/2">assign(socket, attrs)</a>
  </div>
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#assign/3">assign(socket, key, value)</a>
  </div>
    <div class="summary-synopsis"><p>Adds key value pairs to socket assigns.</p></div>
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#channel/3">channel(topic_pattern, module, opts \\ [])</a>
  </div>
    <div class="summary-synopsis"><p>Defines a channel matching the given topic and transports.</p></div>
</div>
  </div>
  <div class="summary-callbacks summary">
    <h2>
      <a href="#callbacks">Callbacks</a>
    </h2>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#c:connect/2">connect(params, t)</a>
  </div>
    <div class="summary-synopsis"><p>Receives the socket params and authenticates the connection.</p></div>
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#c:connect/3">connect(params, t, connect_info)</a>
  </div>
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#c:id/1">id(t)</a>
  </div>
    <div class="summary-synopsis"><p>Identifies the socket connection.</p></div>
</div>
  </div>
        </section>

        <section id="types" class="details-list">
          <h1 class="section-heading">
            <a class="hover-link" href="#types">
              <span class="icon-link" aria-hidden="true"></span>
              <span class="sr-only">Link to this section</span>
            </a>
Types          </h1>
          <div class="types-list">
<section class="detail" id="t:t/0">
  <div class="detail-header">
    <a href="#t:t/0" class="detail-link" title="Link to this type">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this type</span>
    </a>
    <h1 class="signature">t()</h1>
      <a href="https://github.com/phoenixframework/phoenix/blob/v1.4.15/lib/phoenix/socket.ex#L247" class="view-source" rel="help" title="View Source">
       <span class="icon-code" aria-hidden="true"></span>
       <span class="sr-only">View Source</span>
     </a>
      <div class="specs">
          <pre>t() :: %Phoenix.Socket{
  assigns: <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">map</a>(),
  channel: <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">atom</a>(),
  channel_pid: <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">pid</a>(),
  endpoint: <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">atom</a>(),
  handler: <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">atom</a>(),
  id: <a href="https://hexdocs.pm/elixir/String.html#t:t/0">String.t</a>() | nil,
  join_ref: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">term</a>(),
  joined: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">boolean</a>(),
  private: %{},
  pubsub_server: <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">atom</a>(),
  ref: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">term</a>(),
  serializer: <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">atom</a>(),
  topic: <a href="https://hexdocs.pm/elixir/String.html#t:t/0">String.t</a>(),
  transport: <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">atom</a>(),
  transport_pid: <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">pid</a>()
}</pre>
      </div>
  </div>
  <section class="docstring">
  </section>
</section>
          </div>
        </section>
        <section id="functions" class="details-list">
          <h1 class="section-heading">
            <a class="hover-link" href="#functions">
              <span class="icon-link" aria-hidden="true"></span>
              <span class="sr-only">Link to this section</span>
            </a>
Functions          </h1>
          <div class="functions-list">
<section class="detail" id="assign/2">
  <div class="detail-header">
    <a href="#assign/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">assign(socket, attrs)</h1>
      <a href="https://github.com/phoenixframework/phoenix/blob/v1.4.15/lib/phoenix/socket.ex#L319" class="view-source" rel="help" title="View Source">
       <span class="icon-code" aria-hidden="true"></span>
       <span class="sr-only">View Source</span>
     </a>
  </div>
  <section class="docstring">
  </section>
</section>
<section class="detail" id="assign/3">
  <div class="detail-header">
    <a href="#assign/3" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">assign(socket, key, value)</h1>
      <a href="https://github.com/phoenixframework/phoenix/blob/v1.4.15/lib/phoenix/socket.ex#L315" class="view-source" rel="help" title="View Source">
       <span class="icon-code" aria-hidden="true"></span>
       <span class="sr-only">View Source</span>
     </a>
  </div>
  <section class="docstring">
<p>Adds key value pairs to socket assigns.</p>
<p>A single key value pair may be passed, a keyword list or map
of assigns may be provided to be merged into existing socket
assigns.</p>
<h2 id="assign/3-examples" class="section-heading">
  <a href="#assign/3-examples" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Examples
</h2>

<pre><code class="nohighlight makeup elixir"><span class="gp unselectable">iex&gt; </span><span class="n">assign</span><span class="p" data-group-id="1308151982-1">(</span><span class="n">socket</span><span class="p">,</span><span class="w"> </span><span class="ss">:name</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Elixir&quot;</span><span class="p" data-group-id="1308151982-1">)</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="n">assign</span><span class="p" data-group-id="1308151982-2">(</span><span class="n">socket</span><span class="p">,</span><span class="w"> </span><span class="ss">name</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;Elixir&quot;</span><span class="p">,</span><span class="w"> </span><span class="ss">logo</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;ðŸ’§&quot;</span><span class="p" data-group-id="1308151982-2">)</span></code></pre>
  </section>
</section>
<section class="detail" id="channel/3">
    <span id="channel/2"></span>
  <div class="detail-header">
    <a href="#channel/3" class="detail-link" title="Link to this macro">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this macro</span>
    </a>
    <h1 class="signature">channel(topic_pattern, module, opts \\ [])</h1>
      <a href="https://github.com/phoenixframework/phoenix/blob/v1.4.15/lib/phoenix/socket.ex#L350" class="view-source" rel="help" title="View Source">
       <span class="icon-code" aria-hidden="true"></span>
       <span class="sr-only">View Source</span>
     </a>
      <span class="note">(macro)</span>
  </div>
  <section class="docstring">
<p>Defines a channel matching the given topic and transports.</p>
<ul>
<li><code class="inline">topic_pattern</code> - The string pattern, for example <code class="inline">&quot;room:*&quot;</code>, <code class="inline">&quot;users:*&quot;</code>,
or <code class="inline">&quot;system&quot;</code>
</li>
<li><code class="inline">module</code> - The channel module handler, for example <code class="inline">MyApp.RoomChannel</code>
</li>
<li><code class="inline">opts</code> - The optional list of options, see below
</li>
</ul>
<h2 id="channel/3-options" class="section-heading">
  <a href="#channel/3-options" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Options
</h2>

<ul>
<li><code class="inline">:assigns</code> - the map of socket assigns to merge into the socket on join
</li>
</ul>
<h2 id="channel/3-examples" class="section-heading">
  <a href="#channel/3-examples" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Examples
</h2>

<pre><code class="nohighlight makeup elixir"><span class="n">channel</span><span class="w"> </span><span class="s">&quot;topic1:*&quot;</span><span class="p">,</span><span class="w"> </span><span class="nc">MyChannel</span></code></pre>
<h2 id="channel/3-topic-patterns" class="section-heading">
  <a href="#channel/3-topic-patterns" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Topic Patterns
</h2>

<p>The <code class="inline">channel</code> macro accepts topic patterns in two flavors. A splat (the <code class="inline">*</code>
character) argument can be provided as the last character to indicate a
<code class="inline">&quot;topic:subtopic&quot;</code> match. If a plain string is provided, only that topic will
match the channel handler. Most use-cases will use the <code class="inline">&quot;topic:*&quot;</code> pattern to
allow more versatile topic scoping.</p>
<p>See <a href="Phoenix.Channel.html"><code class="inline">Phoenix.Channel</code></a> for more information</p>
  </section>
</section>
          </div>
        </section>
        <section id="callbacks" class="details-list">
          <h1 class="section-heading">
            <a class="hover-link" href="#callbacks">
              <span class="icon-link" aria-hidden="true"></span>
              <span class="sr-only">Link to this section</span>
            </a>
Callbacks          </h1>
          <div class="callbacks-list">
<section class="detail" id="c:connect/2">
  <div class="detail-header">
    <a href="#c:connect/2" class="detail-link" title="Link to this callback">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this callback</span>
    </a>
    <h1 class="signature">connect(params, t)</h1>
      <a href="https://github.com/phoenixframework/phoenix/blob/v1.4.15/lib/phoenix/socket.ex#L203" class="view-source" rel="help" title="View Source">
       <span class="icon-code" aria-hidden="true"></span>
       <span class="sr-only">View Source</span>
     </a>
      <span class="note">(optional)</span>
      <div class="specs">
          <pre>connect(params :: <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">map</a>(), <a href="#t:t/0">t</a>()) :: {:ok, <a href="#t:t/0">t</a>()} | :error</pre>
      </div>
  </div>
  <section class="docstring">
<p>Receives the socket params and authenticates the connection.</p>
<h2 id="c:connect/2-socket-params-and-assigns" class="section-heading">
  <a href="#c:connect/2-socket-params-and-assigns" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Socket params and assigns
</h2>

<p>Socket params are passed from the client and can
be used to verify and authenticate a user. After
verification, you can put default assigns into
the socket that will be set for all channels, ie</p>
<pre><code class="nohighlight makeup elixir"><span class="p" data-group-id="9974646941-1">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="n">assign</span><span class="p" data-group-id="9974646941-2">(</span><span class="n">socket</span><span class="p">,</span><span class="w"> </span><span class="ss">:user_id</span><span class="p">,</span><span class="w"> </span><span class="n">verified_user_id</span><span class="p" data-group-id="9974646941-2">)</span><span class="p" data-group-id="9974646941-1">}</span></code></pre>
<p>To deny connection, return <code class="inline">:error</code>.</p>
<p>See <a href="Phoenix.Token.html"><code class="inline">Phoenix.Token</code></a> documentation for examples in
performing token verification on connect.</p>
  </section>
</section>
<section class="detail" id="c:connect/3">
  <div class="detail-header">
    <a href="#c:connect/3" class="detail-link" title="Link to this callback">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this callback</span>
    </a>
    <h1 class="signature">connect(params, t, connect_info)</h1>
      <a href="https://github.com/phoenixframework/phoenix/blob/v1.4.15/lib/phoenix/socket.ex#L204" class="view-source" rel="help" title="View Source">
       <span class="icon-code" aria-hidden="true"></span>
       <span class="sr-only">View Source</span>
     </a>
      <span class="note">(optional)</span>
      <div class="specs">
          <pre>connect(params :: <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">map</a>(), <a href="#t:t/0">t</a>(), connect_info :: <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">map</a>()) ::
  {:ok, <a href="#t:t/0">t</a>()} | :error</pre>
      </div>
  </div>
  <section class="docstring">
  </section>
</section>
<section class="detail" id="c:id/1">
  <div class="detail-header">
    <a href="#c:id/1" class="detail-link" title="Link to this callback">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this callback</span>
    </a>
    <h1 class="signature">id(t)</h1>
      <a href="https://github.com/phoenixframework/phoenix/blob/v1.4.15/lib/phoenix/socket.ex#L220" class="view-source" rel="help" title="View Source">
       <span class="icon-code" aria-hidden="true"></span>
       <span class="sr-only">View Source</span>
     </a>
      <div class="specs">
          <pre>id(<a href="#t:t/0">t</a>()) :: <a href="https://hexdocs.pm/elixir/String.html#t:t/0">String.t</a>() | nil</pre>
      </div>
  </div>
  <section class="docstring">
<p>Identifies the socket connection.</p>
<p>Socket IDs are topics that allow you to identify all sockets for a given user:</p>
<pre><code class="nohighlight makeup elixir"><span class="kd">def</span><span class="w"> </span><span class="nf">id</span><span class="p" data-group-id="2621164282-1">(</span><span class="n">socket</span><span class="p" data-group-id="2621164282-1">)</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;users_socket:</span><span class="si" data-group-id="2621164282-2">#{</span><span class="n">socket</span><span class="o">.</span><span class="n">assigns</span><span class="o">.</span><span class="n">user_id</span><span class="si" data-group-id="2621164282-2">}</span><span class="s">&quot;</span></code></pre>
<p>Would allow you to broadcast a <code class="inline">&quot;disconnect&quot;</code> event and terminate
all active sockets and channels for a given user:</p>
<pre><code class="nohighlight makeup elixir"><span class="nc">MyApp.Endpoint</span><span class="o">.</span><span class="n">broadcast</span><span class="p" data-group-id="9878115410-1">(</span><span class="s">&quot;users_socket:&quot;</span><span class="w"> </span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="n">user</span><span class="o">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;disconnect&quot;</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="9878115410-2">%{</span><span class="p" data-group-id="9878115410-2">}</span><span class="p" data-group-id="9878115410-1">)</span></code></pre>
<p>Returning <code class="inline">nil</code> makes this socket anonymous.</p>
  </section>
</section>
          </div>
        </section>
      <footer class="footer">
        <p>
          <span class="line">
            Built using
            <a href="https://github.com/elixir-lang/ex_doc" title="ExDoc" target="_blank" rel="help noopener">ExDoc</a> (v0.21.2),
          </span>
          <span class="line">
            designed by
            <a href="https://twitter.com/dignifiedquire" target="_blank" rel="noopener" title="@dignifiedquire">Friedel Ziegelmayer</a>.
          </span>
        </p>
        <p>
          <button class="line footer-button night-mode-toggle">
            Toggle night mode
          </button>
          <button class="line footer-button tooltips-toggle">
            <span class="tooltips-option-disable">Disable tooltips</span>
            <span class="tooltips-option-enable">Enable tooltips</span>
          </button>
          <button class="line footer-button display-shortcuts-help">
            Display keyboard shortcuts
          </button>
          <button class="line footer-button display-quick-switch">
            Go to a HexDocs package
          </button>
        </p>
      </footer>
    </div>
  </div>
</section>
</div>
  </body>
</html>
